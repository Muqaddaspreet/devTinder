- Create a repository
- Initialize the repository
- node_modules, package.json, package-lock.json
- Install express
- Create a server
- Listen to port 7777
- Write request handlers for /test , /hello
- Install nodemon and update scripts inside package.json
- What are dependencies
- What is the use of "-g" while npm install
- Difference between caret and tilde ('^' vs. '~')
- initialize git
- . gitignore
- Create a remote repo on
- Push all code to remote github origin
- Play with routes and route extensions ex-> /hello , /hello/2
- Order of the routes matter a lot
- install Postman app and make a workspace/cottection > test API call
- Write logic to handle GET, POST, PATCH, DELETE API Calls and test them on Postman Middlebrooks
- Explore routing and use of ? , + ( ) ,\* in the routes
- Use of regex in routes /a/ , /.\*fly$/
- Read the query patterns in the routes
- Read the dynamic routes
- Multiple route handlers
- next()
- next() Function and errors is along with res.send()
- Middlewares and why do we need them
- How express js handles requests behind the scenes
- Difference between app.use() and app.all().
- write dummy auth middleware for admin and user respectively, but not for user/login route.
- Error handling using app.use("/", (err, req, res, next) => {})
- Create a cluster on mongoDB official website (Mongo Atlas)
- Install mongoose
- Connect the application to the
  Database "Connection-url"/devTinder
- Call the connectDB function and connect to the Database before starting the application on 3000
- Create a User schema and user Model
- Create POST /signup API to add data to database
- Push some documents using API calls from postman
- Error Handling using try - catch
- Difference between javascript object and JSON
- Add the express.json Middleware to our app
- Make our signup API dynamic to receive data from the end user (i.e. Postman)
- User.findOne() with duplicate emails, the oldest one is returned first.
- API - Get user by email
- API - Feed API - GET /feed - get alll the users from the database
- Create a DELETE user API
- Difference between PATCH and PUT
- API - Update a user
- Explore the mongoose documentation for Model methods
- options in a Model.findOneAndUpdate() method
- API - Update a userAPI with emailId
- Explore schemaType options from the documentation
- add required, unique, lowercase, min, minLength, trim
- add defaukt
- Create a Custom validate function for gender
- Improve the DB schema - Put all appropriate validations on each fielding schema
- Add timestamps to the userS the chema
- Add API Based on PATCH request & up PUT request
- Data Sanitization - Add api validation for each field
- install validator
- Explore npm validator library functions and use them for Password, email, and PhotoURL.
- NEVER TRUST req.body -> Always keep validations
- Validate data in SignUp API
- Install bcrypt package
- Create passwordHash usinh bcrypt.hash & save the user with encrypted password
- Create login api
- Compare passwords and throw errors if email and password is invalid.
- Install cokkie-parser
- Just send a dummy cookie to the user
- Create GET /profile API and check if we get the cookie back
- Install jsonwebtoken
- In login API, after email and password validation, create a jwt token and send it to the user inside a cookie
- Read the cookies inside our GET /profile API and find the logged in user
- userAuth middleware
- Add the userAuth middleware in /profile API and a new sendConnectionRequest API
- Set the expiry of JWT token and cookied to 7 days
- Create userScehma method to getJWT()
- Create userSchema method to compare passwordInputByU the ser and passwordHash

- Explore tinder APIs
- Create a list all the APIs we can think of in devTinder
- Group multiple routes under respective routers
- Read documentation for express.Router
- Create routes folder for managing auth, profile, request routers
- Create authRouter,profileRouter,requestRouter
- Import these routers in app.js
- Create POST /logout API
- Create PATCH /profil/edit
- Create PATCH /profile/password API => Forgot password API
- Make sure you validate all data in every POST, PATCH APIs

- Create connexion request schema
- Send connexion request API
- Think about all corner cases and handle them
- $or and $and query in mongodb
- Read about inverse queries. Ex=> Find all users where email!= "xyz@gmail.com"
- schema.pre("save", function () {}) function
- Read the article about Compound indexes
- Why do we need an index in database?
- What are the advantages and disadvantages of indexing?

- Code this API -> POST /request/review/:status/:requestId with proper validations
- Thought process => POST vs GET API
- Read about ref and populate
- Create GET /user/requests/received
- Create GET /user/connections
